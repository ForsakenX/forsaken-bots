class Meth::CommandManager

  attr_reader :commands

  def initialize(bot)
    @bot = bot
    @commands = {}
    @bot.event.register('irc.message.privmsg',Proc.new{|m| privmsg m })
  end

  def register(cmd,obj,callback=Proc.new{|m| obj.command(m) })
    @commands[cmd] = { 
      :obj => obj,
      :callback => callback
    }
    @bot.event.register("meth.command.#{cmd}",callback)
  end

  def cleanup obj
    @commands.each do |cmd,h|
      if h[:obj] == obj
        @bot.event.unregister("meth.command.#{cmd}",h[:callback])
        @commands.delete(cmd) 
      end
    end
  end

  def privmsg m

    # m.message with a command is one of the following
    # ",hi 1 2 3"
    # "MethBot: hi 1 2 3"

    # must become...
    # m.command => hi
    # m.message => 1 2 3

    # look for our nick or target as first word
    # then extract them from the message
    # "(<nick>: |<target>)"
    unless is_command = !m.message.slice!(/^#{Regexp.escape(@bot.nick)}: /).nil?
      # addressed to target
      unless @bot.target.nil?
        is_command = !m.message.slice!(/^#{Regexp.escape(@bot.target)}/).nil?
      end
    else
      named = true
    end

    # "hi 1 2 3"
    # now that nick/target is extracted
    # thats how the message looks
    # includes the command and params

    # if its a pm then its allways a command
    is_command = m.personal if !is_command

    # %w{hi 1 2 3}
    # split words in line
    params = m.line.split(' ')
    m.instance_variable_set(:@params,params)
    class <<m; attr_accessor :params; end

    # "hi"
    # the command
    # so do we have a command?
    command = is_command ? m.params.shift : nil
    m.instance_variable_set(:@command,command)
    class <<m; attr_accessor :command; end

    # was our name addressed?
    m.instance_variable_set(:@named,named)
    class <<m; attr_accessor :named; end

    # m.message is now the command params
    # m.command is now the command
    # m.params is now an array of words after the command

    # call easy to use command event
    if m.command
      @bot.logger.info "[COMMAND] #{m.command.downcase}"
      @bot.event.call("meth.command.#{m.command.downcase}",m)
      @bot.event.call("meth.command",m)
    end

  end

end
class Meth::Plugin

  # pass down instance of bot
  def initialize(bot)
    @bot = bot
    # register message call backs
    %w{unknown quit part listen privmsg notice join}.each do |type|
      @bot.event.register("irc.message.#{type}",Proc.new{|message|
        send(type.to_sym, message) if respond_to?(type.to_sym)
      })
    end
  end

  # reload the plugin
  def reload
    @bot.plugin_manager._load(self.class.name.snake_case)
  end

  def cleanup
    @bot.command_manager.cleanup(self)
  end

end
class Meth::PluginManager

  attr_reader :bot, :glob, :plugins

  def initialize(bot)
    # we belong to this bot instance
    @bot = bot
    # path to plugins
    @glob = "#{DIST}/bots/#{$bot}/plugins/*.rb"
    # plugin instances
    @plugins = {}
    # load plugins
    startup
  end

  # load all the plugins
  def startup
    enabled.each do |plugin|
      _load plugin
    end
    @bot.event.call('meth.plugins.loaded',nil)
  end

  # list of plugins
  def list
    Dir[@glob,"#{DIST}/plugins/*.rb"].map do |plugin|
      File.basename(plugin).gsub('.rb','')
    end
  end
    
  # path to plugin
  def path plugin
    bot_path = @glob.gsub('*',plugin.snake_case)
    global_path = "#{DIST}/plugins/#{plugin.snake_case}.rb"
    return bot_path if FileTest.exists?(bot_path) # bot_path takes precedence
    return global_path if FileTest.exists?(global_path) # global plugin?
    bot_path # default bot_path
  end

  #
  def exists? plugin
    FileTest.exists?(path(plugin))
  end

  # plugin executable?
  def executable? plugin
    FileTest.executable?(path(plugin))
  end

  # list of enabled plugins
  def enabled
    list.select{|plugin| plugin if enabled?(plugin) }
  end

  # plugin enabled?
  def enabled? plugin
    return true if @plugins[plugin]
    return true if executable?(plugin)
    false
  end

  # list loaded plugins
  def loaded
    @plugins.map{|name,instance| name }
  end

  # plugin exists?
  def detect plugin
    list.detect{|p| p.downcase == plugin.downcase }
  end

  def unload plugin
    if p = @plugins[plugin]
      begin
        p.cleanup
      rescue Exception
        @bot.logger.warn "[unload plugin error] #{$!}\n#{$@.join("\n")}"
      end
      @plugins.delete(p)
    end
  end

  def reload plugin
    unload plugin
    load path(plugin)
  end

  # loads a plugin
  # expects snake case
  def _load plugin
    reload plugin
    begin
      constant = Object.const_get(plugin.camel_case)
      @plugins[plugin] = constant.new(@bot)
    rescue Exception
      @bot.logger.warn "[_load plugin error] #{$!}\n#{$@.join("\n")}"
    end
    @bot.logger.info "Bot (#{bot.name}) Loaded Plugin (#{plugin.snake_case})"
    @bot.event.call('meth.plugin.loaded', plugin)
  end

  def reload_all
    enabled.each do |plugin|
      @plugins[plugin].reload
    end
  end

end
